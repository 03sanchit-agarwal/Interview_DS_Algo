#include <bits/stdc++.h>
using namespace std;
class AdjListNode{
	int v;
	int weight;
	public:
		AdjListNode(int _v,int _w){
			v = _v;
			weight = _w;
		}
		int getV(){
			return v;
		}
		int getW(){
			return weight;
		}
};
class Graph{
	int V;
	vector<AdjListNode> *adj;
	void printMST(int* ,int*);
	public:
		Graph(int V);
		~Graph();
		void addEdge(int u,int v,int w);
		void primMST();
};
Graph::Graph(int V){
	this->V = V;
	adj = new vector<AdjListNode> [V];
}
Graph::~Graph(){
	delete[] adj;
}
void Graph::addEdge(int u,int v,int w){
	adj[u].push_back(AdjListNode(v,w));
	adj[v].push_back(AdjListNode(u,w));
}
struct comp{
	bool operator()(AdjListNode p1,AdjListNode p2){
		if(p1.getW()!=p2.getW()){
			return p1.getW()>p2.getW();
		}
	}
};
void Graph::printMST(int parent[],int key[]){
	cout<<"Edge \t Weight\n";
	for(int i=1;i<V;i++){
		cout<<parent[i]<<"-"<<i<<"\t"<<key[i]<<endl;
	}
}
void Graph::primMST(){
	vector<bool> mstSet(V,false);
	int key[V]={INT_MAX};
	for(int i=0;i<V;i++){
		key[i]=INT_MAX;
	}
	priority_queue<AdjListNode,vector<AdjListNode>,comp> pq;
	key[0]=0;
	int parent[V]={-1};
	pq.push(AdjListNode(0,key[0]));
	while(!pq.empty()){
		AdjListNode t = pq.top();
		pq.pop();
		mstSet[t.getV()]=true;
		for(AdjListNode u: adj[t.getV()]){
			if(mstSet[u.getV()]==false&&u.getW()<key[u.getV()]){
				parent[u.getV()]=t.getV();
				key[u.getV()]=u.getW();
				pq.push(u);
			}
		}
		
	}
	printMST(parent,key);
	
}
int main(){
	Graph g(5);
	g.addEdge(0,1,2);
	g.addEdge(0,3,6);
	g.addEdge(1,2,3);
	g.addEdge(1,3,8);
	g.addEdge(1,4,5);
	g.addEdge(2,4,7);
	g.addEdge(3,4,9);
	g.primMST(); 
	return 0;
}
